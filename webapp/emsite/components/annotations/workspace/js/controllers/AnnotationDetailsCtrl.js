// Generated by CoffeeScript 1.4.0

Workspace.controller('AnnotationDetailsCtrl', [
  '$rootScope', '$scope', '$stateParams', '$timeout', 'annotationService', 'fabricJsService', 'annotationSocket', function($rootScope, $scope, $stateParams, $timeout, annotationService, fabricJsService, annotationSocket) {
    var applicationid, commentPin, fromExistingState, getSelf, metaUser, readyToComment, toolkit;
    $rootScope.$broadcast('navigatedTo', 'Annotations');
    annotationSocket.forward('updateAnnotationResponse', $scope);
    annotationSocket.forward('removeAnnotationResponse', $scope);
    /*
    	USER AUTHENTICATION LOGIC
    */

    metaUser = {
      userid: 1,
      name: 'Rob',
      email: md5('jrchipman1@gmail.com')
    };
    $scope.currentUser = metaUser;
    $.getJSON("" + apphome + "/services/json/users/status.json", function(data) {
      $scope.currentUser = data;
      console.log('from user auth:', data);
      return em.unit;
    });
    /*
    	/ USER AUTHENTICATION LOGIC
    */

    /*
    	INITIALIZE CANVAS
    */

    fromExistingState = true;
    $scope.pushAnnotation = function(annotation) {
      fabric.util.enlivenObjects(annotation.group, function(group) {
        var origRenderOnAddRemove;
        origRenderOnAddRemove = $scope.fabric.canvas.renderOnAddRemove;
        $scope.fabric.canvas.renderOnAddRemove = false;
        _.forEach(group, function(item) {
          return $scope.fabric.canvas.add(item);
        });
        $scope.fabric.canvas.renderOnAddRemove = origRenderOnAddRemove;
        $scope.fabric.canvas.renderAll();
        return em.unit;
      });
      $scope.annotations.unshift(annotation);
      $scope.$apply();
      return em.unit;
    };
    $scope.currentAnnotation = _.find(annotationService.mockData, function(item) {
      return item.annotation.id === parseInt($stateParams.annotationID);
    });
    $scope.fabric = fabricJsService.init($scope.currentAnnotation.annotation.path);
    if (fromExistingState) {
      $.getJSON("" + apphome + "/components/annotations/json/dummyAnnotationData.json", function(data) {
        var annotation, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          annotation = data[_i];
          _results.push($scope.pushAnnotation(annotation));
        }
        return _results;
      });
    }
    /*
    	/ INITIALIZE CANVAS
    */

    $scope.selectable = false;
    $scope.canSelect = function() {
      return $scope.selectable;
    };
    $scope.colorpicker = {
      hex: '#000fff'
    };
    $scope.brushWidth = 5;
    $scope.mouseDown = null;
    $scope.left = 0;
    $scope.top = 0;
    $scope.currentAnnotationIndex = 1;
    $scope.newCommentText = null;
    $scope.annotations = [];
    $scope.eventIndex = 0;
    $scope.annotationAction = null;
    $scope.currentAnnotationGroup = [];
    $scope.currentAnnotationGroupId = 0;
    $scope.thumbs = [];
    /*
    	FABRIC TOOLS SETUP
    */

    getSelf = function(name) {
      return _.find(toolkit, {
        name: name
      });
    };
    toolkit = [
      {
        name: 'disabled',
        properties: {
          isDrawingMode: false
        },
        annotating: false
      }, {
        name: 'draw',
        properties: {
          isDrawingMode: true
        },
        annotating: true
      }, {
        name: 'move',
        properties: {
          isDrawingMode: false
        },
        annotating: false
      }, {
        name: 'shape',
        properties: {
          isDrawingMode: false
        },
        annotating: true,
        type: 'circle',
        types: [
          {
            name: 'circle',
            type: fabric.Circle,
            blank: {
              radius: 1,
              strokeWidth: 5,
              selectable: false,
              fill: "",
              originX: 'left',
              originY: 'top'
            },
            drawparams: function(pointer) {
              return {
                radius: Math.abs($scope.left - pointer.x)
              };
            }
          }, {
            name: 'rectangle',
            type: fabric.Rect,
            blank: {
              height: 1,
              width: 1,
              strokeWidth: 5,
              selectable: false,
              fill: "",
              originX: 'left',
              originY: 'top'
            },
            drawparams: function(pointer) {
              return {
                width: -$scope.left + pointer.x,
                height: -$scope.top + pointer.y
              };
            }
          }
        ],
        events: {
          mouseup: function(e, canvas) {
            return $scope.mouseDown = false;
          },
          mousedown: function(e, canvas) {
            var pointer, shape, spec, type, we;
            $scope.mouseDown = true;
            pointer = canvas.getPointer(e.e);
            we = getSelf('shape');
            type = _.findWhere($scope.currentTool.types, {
              name: $scope.currentTool.type
            });
            spec = type.blank;
            spec.stroke = $scope.colorpicker.hex;
            spec.left = pointer.x;
            spec.top = pointer.y;
            shape = new type.type(spec);
            canvas.add(shape);
            return em.unit;
          },
          objectadded: null,
          mousemove: function(e, canvas) {
            var pointer, shape, type, we;
            if ($scope.mouseDown) {
              we = getSelf('shape');
              pointer = canvas.getPointer(e.e);
              shape = canvas.getObjects()[canvas.getObjects().length - 1];
              type = _.findWhere($scope.currentTool.types, {
                name: $scope.currentTool.type
              });
              shape.set(type.drawparams(pointer));
              canvas.renderAll();
            }
            return em.unit;
          }
        }
      }, {
        name: 'comment',
        properties: {
          isDrawingMode: false
        },
        annotating: true,
        events: {
          mouseup: null,
          mousedown: null,
          objectadded: null
        }
      }, {
        name: 'arrow',
        properties: {
          isDrawingMode: false
        },
        annotating: true
      }, {
        name: 'text',
        properties: {
          isDrawingMode: false
        },
        annotating: true
      }, {
        name: 'zoom',
        properties: {
          isDrawingMode: false
        },
        annotating: false,
        events: {
          mouseup: null,
          mousemove: function(o, canvas) {
            var SCALE_FACTOR, delta, klass, objects, pointer, transform, _i, _len;
            if ($scope.mouseDown) {
              SCALE_FACTOR = 0.01;
              pointer = canvas.getPointer(o.e);
              delta = $scope.left - pointer.x;
              objects = canvas.getObjects();
              delta = delta * SCALE_FACTOR;
              transform = [1 + delta, 0, 0, 1 + delta, 0, 0];
              console.log(transform);
              for (_i = 0, _len = objects.length; _i < _len; _i++) {
                klass = objects[_i];
                klass.transformMatrix = transform;
                klass.setCoords();
              }
              canvas.backgroundImage.transformMatrix = transform;
              canvas.setWidth(canvas.backgroundImage.width * canvas.backgroundImage.transformMatrix[0]);
              return canvas.setHeight(canvas.backgroundImage.height * canvas.backgroundImage.transformMatrix[3]);
            }
          },
          mousedown: function(o, canvas) {
            return $scope.left = canvas.getPointer(o.e).x;
          }
        }
      }, {
        name: 'colorpicker',
        properties: {},
        annotating: false
      }, {
        name: 'load',
        properties: {},
        annotating: false
      }, {
        name: 'export',
        properties: {},
        annotating: false
      }
    ];
    $scope.fabric.toolkit = toolkit;
    /*
    	/ FABRIC TOOLS SETUP
    */

    $scope.testSocket = function() {
      return em.unit;
    };
    /*
    	JSON IMPORT/EXPORT LOGIC
    */

    applicationid = "emshare";
    $scope.loadImages = function() {
      var debugVar, imageArray;
      imageArray = [];
      /*
      		$.getJSON "#{apphome}/components/annotations/json/viewassets.json?id=#{collectionid}", (data) ->
      			console.log 'from get images:', data
      */

      debugVar = $.ajax({
        type: "GET",
        url: "" + apphome + "/components/annotations/json/viewassets.json?id=" + collectionid,
        async: false,
        error: function(data, status, err) {
          console.log('from error:', data);
          console.log('status:', status);
          console.log('error:', err);
          return em.unit;
        },
        success: function(data) {
          console.log('from success:', data);
          imageArray = data;
          return em.unit;
        },
        failure: function(errMsg) {
          alert(errMsg);
          return em.unit;
        }
      });
      console.log('from finish:', imageArray);
      return imageArray;
    };
    $scope.exportCanvas = function() {
      var data;
      data = JSON.stringify($scope.fabric.canvas.toJSON());
      $.ajax({
        type: "POST",
        url: "services/json/search/data/annotation?save=true?field=annotationid&field.value=" + $scope.currentAnnotation.id + "&field=json&field.value=" + data,
        success: function(data) {
          alert("Success!");
          return em.unit;
        },
        failure: function(errMsg) {
          alert(errMsg);
          return em.unit;
        }
      });
      return em.unit;
    };
    $scope.thumbs = $scope.loadImages();
    console.log($scope.thumbs);
    /*
    	/ JSON IMPORT/EXPORT LOGIC
    */

    /*
    	TOOLBAR SELECTOR METHODS
    */

    $scope.shapeToolType = 'circle';
    ($scope.selectTool = function(toolname) {
      var prop;
      if (!$scope.readyToComment) {
        $scope.currentTool = _.findWhere($scope.fabric.toolkit, {
          name: toolname
        });
        for (prop in $scope.currentTool.properties) {
          $scope.fabric.canvas[prop] = $scope.currentTool.properties[prop];
        }
        if ($scope.currentTool.name === 'draw') {
          $scope.fabric.canvas.freeDrawingBrush.color = $scope.colorpicker.hex;
          $scope.fabric.canvas.freeDrawingBrush.width = $scope.brushWidth;
        }
      }
      return em.unit;
    })('disabled');
    $scope.setShapeTypeFromUi = function(type) {
      var prop;
      $scope.currentTool = _.findWhere($scope.fabric.toolkit, {
        name: 'shape'
      });
      $scope.currentTool.type = type;
      $scope.shapeToolType = $scope.currentTool.type;
      for (prop in $scope.currentTool.properties) {
        $scope.fabric.canvas[prop] = $scope.currentTool.properties[prop];
      }
      return em.unit;
    };
    /*
    	This whole process is muddled, what should happen is simple:
    	user clicks to draw a shape, that shape is added to the current group upon object:added
    	a timeout function begins to check if they are done annotating
    	if the user clicks again within a time window, the timeout function is cancelled
    	repeat process until...
    	user finishes annotation, they should be prompted for a comment
    	a pin should be created and added into the annotationGroup data
    	the pin should be rendered on screen somewhere appropriate and...
    	the comment should be added to scope with annotationGroup data to be attached to comment
    */

    $scope.setShapeType = function(type) {
      if (type === 'circle') {
        $scope.currentTool.type = fabric.Circle;
      } else if (type === 'rectangle') {
        $scope.currentTool.type = fabric.Rect;
      }
      return em.unit;
    };
    /*
    	/ TOOLBAR SELECTOR METHODS
    */

    commentPin = function() {
      return new fabric.Group([
        new fabric.Circle({
          radius: 18.5,
          fill: "#fff"
        }), new fabric.Circle({
          radius: 14,
          fill: "#4fabe5",
          top: 5,
          left: 5
        }), new fabric.Text($scope.currentAnnotationIndex.toString(), {
          fontSize: 20,
          fill: "#fff",
          left: 13,
          top: 4
        })
      ], {
        evented: true,
        top: $scope.top - 15,
        left: $scope.left - 15,
        lockScalingX: false,
        lockScalingY: false,
        selectable: true
      });
    };
    readyToComment = function() {
      $scope.selectTool('disabled');
      $scope.readyToComment = true;
      $scope.fabric.canvas.isDrawingMode = false;
      $timeout((function() {
        $('#user-comment-input').focus();
        return em.unit;
      }), 100);
      $('.upper-canvas').css({
        'background': 'rgba(255,255,255,0.7)'
      });
      return em.unit;
    };
    $scope.addComment = function() {
      var annotationSpec, pin;
      pin = commentPin();
      $scope.fabric.canvas.add(pin);
      $scope.currentAnnotationGroup.push(pin);
      annotationSpec = {
        id: $scope.currentAnnotationIndex++,
        group: $scope.currentAnnotationGroup,
        user: $scope.currentUser,
        comment: {
          type: 'normal',
          text: $scope.newCommentText,
          timestamp: moment().fromNow()
        }
      };
      console.log(JSON.stringify(annotationSpec));
      $scope.annotations.unshift(annotationSpec);
      $scope.currentAnnotationGroup = [];
      $scope.newCommentText = null;
      $scope.readyToComment = false;
      $('.upper-canvas').css({
        'background': 'none'
      });
      $scope.left = null;
      $scope.top = null;
      annotationSocket.emit('updateAnnotation', JSON.stringify(annotationSpec));
      return em.unit;
    };
    $scope.removeComment = function(annotationid) {
      var annotationToRemove;
      annotationToRemove = _.findWhere($scope.annotations, {
        id: annotationid
      });
      annotationSocket.emit('removeAnnotation', annotationid);
      _.forEach(annotationToRemove.group, function(item) {
        return $scope.fabric.canvas.remove(item);
      });
      $scope.annotations = _.without($scope.annotations, annotationToRemove);
      return em.unit;
    };
    $scope.cancelComment = function() {
      _.forEach($scope.currentAnnotationGroup, function(item) {
        return $scope.fabric.canvas.remove(item);
      });
      $scope.readyToComment = false;
      $scope.newCommentText = null;
      $scope.currentAnnotationGroup = [];
      $('.upper-canvas').css({
        'background': 'none'
      });
      return em.unit;
    };
    /*
    	Because of fabric.js quirks with object addition (on addition to the canvas, the object is mutated to a state where it cannot be added again)
    	the logic for transmitting the state of the canvas must not rely on the ability to pass the objects
    	Luckily, Fabric.js includes handy toJSON and loadFromJSON methods that can send the entire canvas object
    	All we need to do is attach the information we need to that object and let our data be transmitted along with the canvas
    	Then we can load the canvas, let fabric do all of its logic, and insert our own data into hte current $scope when it is finished
    	This may cause complications with being able to track the comments, because the efforts to link annotation with comment
    	will be thwarted using this method of canvas transport.  This also means that large annotations may be slow to load
    	since the process involves completely destroying and rebuilding the entire canvas
    
    	It also remains to be seen if attributes added to the canvas object will still be populated on the loaded canvas (don't see why not)
    */

    /*
    	FABRIC CANVAS EVENT HANDLERS
    */

    $scope.$on('socket:updateAnnotationResponse', function(e, data) {
      var incomingAnnotation;
      incomingAnnotation = JSON.parse(data);
      incomingAnnotation.id = $scope.currentAnnotationIndex++;
      $scope.pushAnnotation(incomingAnnotation);
      return em.unit;
    });
    $scope.$on('socket:removeAnnotationResponse', function(e, id) {
      var clientCopy;
      clientCopy = _.findWhere($scope.annotations, {
        id: id
      });
      console.log('trying to remove this: ', id, ': ', clientCopy);
      _.forEach(clientCopy.group, function(item) {
        return $scope.fabric.canvas.remove(item);
      });
      $scope.annotations = _.without($scope.annotations, clientCopy);
      return em.unit;
    });
    $scope.fabric.canvas.on('mouse:down', function(e) {
      var pointer, _ref;
      pointer = $scope.fabric.canvas.getPointer(e.e);
      $scope.mouseDown = true;
      $scope.left = pointer.x;
      $scope.top = pointer.y;
      if (!$scope.readyToComment) {
        if ($scope.annotationAction !== null) {
          console.log('canceling annotationAction');
          $timeout.cancel($scope.annotationAction);
        }
        console.log('DOING SOMETHING!!! Something is wrong with disabled tool/ offset calculations');
        if ((_ref = $scope.currentTool.events) != null) {
          if (typeof _ref.mousedown === "function") {
            _ref.mousedown(e, $scope.fabric.canvas);
          }
        }
      }
      return em.unit;
    });
    $scope.fabric.canvas.on('mouse:up', function(e) {
      var _ref;
      $scope.mouseDown = false;
      if ($scope.currentTool.annotating && !$scope.readyToComment) {
        if ($scope.currentTool.name === 'comment') {
          console.log('Calling readyToComment() now');
          readyToComment();
        } else {
          console.log('Calling delayed readyToComment()');
          $scope.annotationAction = $timeout(readyToComment, 1000);
        }
      }
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.mouseup === "function") {
          _ref.mouseup(e, $scope.fabric.canvas);
        }
      }
      return em.unit;
    });
    $scope.fabric.canvas.on('mouse:move', function(e) {
      var _ref;
      $scope.fabric.canvas.calcOffset();
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.mousemove === "function") {
          _ref.mousemove(e, $scope.fabric.canvas);
        }
      }
      return em.unit;
    });
    $scope.fabric.canvas.on('object:added', function(obj) {
      var _ref;
      if ($scope.currentTool.annotating) {
        obj.target.selectable = $scope.canSelect();
        $scope.currentAnnotationGroup.push(obj.target);
      }
      if ((_ref = $scope.currentTool.events) != null) {
        if (typeof _ref.objectadded === "function") {
          _ref.objectadded(obj, $scope.fabric.canvas);
        }
      }
      $scope.fabric.canvas.calcOffset();
      $scope.fabric.canvas.renderAll();
      if (!$scope.left) {
        $scope.left = obj.target.left;
      }
      if (!$scope.top) {
        $scope.top = obj.target.top;
      }
      return em.unit;
    });
    return em.unit;
    /*
    	/ FABRIC CANVAS EVENT HANDLERS
    */

  }
]);
